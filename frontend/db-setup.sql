create table public.account (
  id text not null,
  "accountId" text not null,
  "providerId" text not null,
  "userId" text not null,
  "accessToken" text null,
  "refreshToken" text null,
  "idToken" text null,
  "accessTokenExpiresAt" timestamp with time zone null,
  "refreshTokenExpiresAt" timestamp with time zone null,
  scope text null,
  password text null,
  "createdAt" timestamp with time zone not null default CURRENT_TIMESTAMP,
  "updatedAt" timestamp with time zone not null,
  constraint account_pkey primary key (id),
  constraint account_userId_fkey foreign KEY ("userId") references "user" (id) on delete CASCADE
) TABLESPACE pg_default;

create table public.chat_messages (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  queue_id bigint null,
  role text null,
  content text null,
  type text null,
  attachments text null,
  "order" integer null,
  timestamp timestamp with time zone null,
  constraint chat_messages_pkey primary key (id),
  constraint chat_messages_queue_id_fkey foreign KEY (queue_id) references chat_queues (id) on delete CASCADE
) TABLESPACE pg_default;

create table public.chat_queues (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  user_id text null,
  customer_name text null,
  customer_number text null,
  status text null,
  last_message_at date null,
  human_requested boolean null default false,
  constraint chat_queues_pkey primary key (id),
  constraint chat_queues_user_id_fkey foreign KEY (user_id) references "user" (id) on delete CASCADE
) TABLESPACE pg_default;

create table public.documents (
  id bigserial not null,
  content text null,
  embedding public.vector null,
  title text null,
  constraint documents_pkey primary key (id)
) TABLESPACE pg_default;

create table public.session (
  id text not null,
  "expiresAt" timestamp with time zone not null,
  token text not null,
  "createdAt" timestamp with time zone not null default CURRENT_TIMESTAMP,
  "updatedAt" timestamp with time zone not null,
  "ipAddress" text null,
  "userAgent" text null,
  "userId" text not null,
  "impersonatedBy" text null,
  constraint session_pkey primary key (id),
  constraint session_token_key unique (token),
  constraint session_userId_fkey foreign KEY ("userId") references "user" (id) on delete CASCADE
) TABLESPACE pg_default;

create table public.user (
  id text not null,
  name text not null,
  email text not null,
  "emailVerified" boolean not null,
  image text null,
  "createdAt" timestamp with time zone not null default CURRENT_TIMESTAMP,
  "updatedAt" timestamp with time zone not null default CURRENT_TIMESTAMP,
  role text null,
  banned boolean null,
  "banReason" text null,
  "banExpires" timestamp with time zone null,
  "customerNumber" text null,
  constraint user_pkey primary key (id),
  constraint user_customerNumber_key unique ("customerNumber"),
  constraint user_email_key unique (email)
) TABLESPACE pg_default;

create table public.verification (
  id text not null,
  identifier text not null,
  value text not null,
  "expiresAt" timestamp with time zone not null,
  "createdAt" timestamp with time zone not null default CURRENT_TIMESTAMP,
  "updatedAt" timestamp with time zone not null default CURRENT_TIMESTAMP,
  constraint verification_pkey primary key (id)
) TABLESPACE pg_default;

/* ----------------------------------------------------------------------- */

-- Enable the pgvector extension
create extension if not exists vector;

-- Create a table to store your documents and their embeddings
create table
  documents (
    id bigserial primary key,
    content text, -- The text content of your document chunk
    embedding vector (1536) -- Corresponds to the OpenAI text-embedding-ada-002 model
  );

-- Create a function to search for documents
create function match_documents (
  query_embedding vector(1536),
  match_threshold float,
  match_count int
)
returns table (
  id bigint,
  content text,
  similarity float
)
language plpgsql
as $$
begin
  return query
  select
    documents.id,
    documents.content,
    1 - (documents.embedding <=> query_embedding) as similarity
  from documents
  where 1 - (documents.embedding <=> query_embedding) > match_threshold
  order by documents.embedding <=> query_embedding
  limit match_count;
end;
$$;